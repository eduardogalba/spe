searchData={"items":[{"type":"module","doc":"**Job** module is responsible for managing the execution of tasks\r\nin a distributed system. It handles task assignment to workers,\r\nmonitors their completion, and manages the overall state of the job.\r\nIt uses a GenServer to maintain the state and handle asynchronous\r\nmessages related to task execution and worker readiness.","title":"Job","ref":"Job.html"},{"type":"module","doc":"To use this module, you would typically start a job with `Job.start_link/1` and then\r\nsend tasks to it using `Job.task_completed/2` and `Job.worker_ready/2`.\r\nIt is designed to work with a distributed system where tasks can be executed by multiple workers,\r\nand it handles the complexities of task dependencies and worker availability.\r\n```elixir\r\n{:ok, job_pid} = Job.start_link(%{id: \"job_1\", tasks: %{\"task_1\" => %{\"exec\" => \"some_exec\", \"timeout\" => 5000}}})\r\nJob.worker_ready(job_pid, self())\r\nJob.task_completed(job_pid, {\"task_1\", {:result, \"task_result\"}, self()})\r\n```","title":"Usage: - Job","ref":"Job.html#module-usage"},{"type":"function","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","title":"Job.child_spec/1","ref":"Job.html#child_spec/1"},{"type":"function","doc":"Handles asynchronous messages related to worker readiness and task completion.\r\nThis function processes messages sent to the job, such as when a worker is ready\r\nto take tasks or when a task has been completed by a worker. It updates the job state\r\naccordingly and checks if the job should finish based on the current state.\r\n#### Parameters:\r\n- `message`: The message to be processed, which can be either a worker readiness notification\r\n  or a task completion notification.\r\n- `state`: The current state of the job, which includes ongoing tasks, free workers, and results.\r\n#### Returns:\r\n- `{:noreply, new_state}`: Returns the updated state of the job wrapped in a `:noreply` tuple.\r\n#### Example:\r\n```elixir\r\nGenServer.cast(job_pid, {:worker_ready, worker_pid})\r\nGenServer.cast(job_pid, {:task_terminated, {task_name, {:result, value}, worker_pid}})\r\n```","title":"Job.handle_cast/2","ref":"Job.html#handle_cast/2"},{"type":"function","doc":"Handles informational messages related to worker readiness notifications.\r\nThis function processes messages sent to the job when a worker is ready\r\nto take tasks. It updates the job state by adding the worker to the list of\r\nfree workers and logs the addition of the new worker.\r\n#### Parameters:\r\n- `message`: The informational message containing the worker PID.\r\n- `state`: The current state of the job, which includes ongoing tasks, free workers, and results.\r\n#### Returns:\r\n- `{:noreply, state}`: Returns the current state of the job wrapped in a `:noreply` tuple.\r\n#### Example:\r\n```elixir\r\nGenServer.handle_info({:notify_ready, worker_pid}, state)\r\n```","title":"Job.handle_info/2","ref":"Job.html#handle_info/2"},{"type":"function","doc":"Initializes the job state when the GenServer starts.\r\nThis function sets up the initial state of the job, including\r\nthe task returns, ongoing tasks, free workers, results, and the start time.\r\nIt also logs the start of the job for debugging purposes.\r\n#### Parameters:\r\n- `state`: The initial state of the job, which includes the job ID and tasks to be executed.\r\n#### Returns:\r\n- `{:ok, state}`: Returns the initial state of the job wrapped in an `:ok` tuple.\r\n#### Example:\r\n```elixir\r\n{:ok, initial_state} = Job.init(%{id: \"job_1\", tasks: %{\"task_1\" => %{\"exec\" => \"some_exec\", \"timeout\" => 5000}}})\r\n```","title":"Job.init/1","ref":"Job.html#init/1"},{"type":"function","doc":"Starts the job with the given initial state.\r\nThis function initializes the job by setting up the necessary state\r\nand prepares it to handle tasks and workers. It also logs the start of the\r\n#### Parameters:\r\n- `state`: The initial state of the job, which includes the job ID and tasks to be executed.   Returns::\r\n- `{:ok, pid}`: Returns the PID of the started job process wrapped in an `:ok` tuple.\r\n  mple:\r\n:\r\n```elixir\r\n{:ok, job_pid} = Job.start_link(%{id: \"job_1\", tasks: %{\"task_1\" => %{\"exec\" => \"some_exec\", \"timeout\" => 5000}\r\n}})\r\n```","title":"Job.start_link/1","ref":"Job.html#start_link/1"},{"type":"function","doc":"Notifies the job that a task has been completed by a worker.\r\nThis function is called when a worker finishes executing a task.\r\nIt sends a message to the job process indicating that the task has been completed,\r\nalong with the task name, result, and worker PID. The job process will then\r\nhandle this message to update its state accordingly.\r\n#### Parameters:\r\n- `job_id`: The ID of the job process that is handling the task.\r\n- `task_name`: The name of the task that has been completed.\r\n- `result`: The result of the task execution, which can be a success or failure.\r\n- `worker_pid`: The PID of the worker that completed the task.\r\n#### Example:\r\n```elixir\r\nJob.task_completed(job_id, {\"task_1\", {:result, \"task_result\"}, worker_pid})\r\n```","title":"Job.task_completed/2","ref":"Job.html#task_completed/2"},{"type":"function","doc":"Notifies the job that a worker is ready to take tasks.\r\nThis function is called when a worker signals that it is ready to receive tasks.\r\nIt sends a message to the job process indicating that the worker is ready,\r\nallowing the job to assign tasks to the worker as they become available.\r\n#### Parameters:\r\n- `job_pid`: The PID of the job process that is managing the workers.\r\n- `worker_pid`: The PID of the worker that is ready to take tasks.\r\n#### Example:\r\n```elixir\r\nJob.worker_ready(job_pid, worker_pid)\r\n```","title":"Job.worker_ready/2","ref":"Job.html#worker_ready/2"},{"type":"module","doc":"**JobManager** is responsible for managing jobs, including submitting jobs, starting them, and handling their plans.\r\nIt uses a GenServer to maintain state and handle calls related to job management.","title":"JobManager","ref":"JobManager.html"},{"type":"module","doc":"- Start the JobManager\r\n```elixir\r\n{:ok, _pid} = JobManager.start_link(num_workers: 4)\r\n```\r\n- Submit a job\r\n```elixir\r\njob_desc = %{\r\n  \"tasks\" => [\r\n    %{\"name\" => \"task1\", \"enables\" => [\"task2\"]},\r\n    %{\"name\" => \"task2\", \"enables\" => []}\r\n  ]\r\n}\r\n{:ok, job_id} = JobManager.submit_job(job_desc)\r\n```\r\n- Start the job\r\n```elixir\r\n{:ok, _job_id} = JobManager.start_job(job_id)\r\n```","title":"Usage: - JobManager","ref":"JobManager.html#module-usage"},{"type":"module","doc":"- The JobManager uses a planning module (`Planner`) to create a plan for the job based on the job description and the number of workers available.\r\n- It handles job submissions and starts jobs based on the plans created.\r\n- The JobManager maintains a state that includes the jobs and their plans, as well as the number of workers available for job execution.\r\n- It logs debug information about job submissions, plans, and task management.","title":"Notes: - JobManager","ref":"JobManager.html#module-notes"},{"type":"module","doc":"- `GenServer`: For managing the state and handling calls.\r\n- `Logger`: For logging debug information.\r\n- `Planner`: A module responsible for planning jobs based on their descriptions and available workers.","title":"Dependencies: - JobManager","ref":"JobManager.html#module-dependencies"},{"type":"function","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","title":"JobManager.child_spec/1","ref":"JobManager.html#child_spec/1"},{"type":"function","doc":"Handles job submission by receiving a job description, planning the job, and storing it in the state.\r\n#### Parameters:\r\n- `{:submit, job_desc}`: A tuple containing the job description to be submitted.\r\n#### Returns:\r\n- `{:reply, {:ok, job_id}, new_state}`: If the job is successfully planned and stored, it returns the job ID and the updated state.\r\n- `{:reply, {:error, error}, state}`: If there is an error in planning the job, it returns the error and the current state.\r\n#### Example:\r\n```elixir\r\njob_desc = %{\r\n  \"tasks\" => [\r\n    %{\"name\" => \"task1\", \"enables\" => [\"task2\"]},\r\n    %{\"name\" => \"task2\", \"enables\" => []}\r\n  ]\r\n}\r\n{:ok, job_id} = JobManager.submit_job(job_desc)\r\n```","title":"JobManager.handle_call/3","ref":"JobManager.html#handle_call/3"},{"type":"function","doc":"Handles job planning by receiving a job ID and its planned tasks, updating the state with the new plan.\r\n#### Parameters:\r\n- `{:planning, {job_id, job_plan}}`: A tuple containing the job ID and its planned tasks.\r\n#### Returns:\r\n- `{:noreply, new_state}`: The updated state after planning the job.\r\n#### Example:\r\n```elixir\r\njob_id = \"12345\"\r\njob_plan = [%{\"task\" => \"task1\"}, %{\"task\" => \"task2\"}]\r\nJobManager.plan_ready(job_id, job_plan)\r\n```","title":"JobManager.handle_info/2","ref":"JobManager.html#handle_info/2"},{"type":"function","doc":"Initializes the JobManager with a state containing the number of workers, jobs, and waiting jobs.\r\nThe `num_workers` can be set to `:unbound` to allow dynamic worker allocation based on job requirements.\r\nThe `jobs` map will hold the jobs submitted, and `waiting` can be used for jobs that are waiting to be processed.\r\n#### Parameters:\r\n- `state`: The initial state of the JobManager, including the number of workers, jobs, and waiting jobs.\r\n#### Returns:\r\n- `{:ok, state}`: The initial state of the JobManager is returned, ready to handle job submissions and starts.\r\n#### Example:\r\n```elixir\r\n{:ok, _pid} = JobManager.start_link(num_workers: 4)\r\n```","title":"JobManager.init/1","ref":"JobManager.html#init/1"},{"type":"function","doc":"Notifies the JobManager that a job plan is ready for the given job ID.\r\n#### Parameters:\r\n- `job_id`: The ID of the job for which the plan is ready.\r\n- `job_plan`: The planned tasks for the job.\r\n#### Returns:\r\n- `:ok`: If the plan is successfully received and processed.\r\n#### Example:\r\n```elixir\r\njob_id = \"12345\"\r\njob_plan = [%{\"task\" => \"task1\"}, %{\"task\" => \"task2\"}]\r\nJobManager.plan_ready(job_id, job_plan)\r\n```","title":"JobManager.plan_ready/2","ref":"JobManager.html#plan_ready/2"},{"type":"function","doc":"Starts a job with the given job ID.\r\n#### Parameters:\r\n- `job_id`: The ID of the job to be started.\r\n#### Returns:\r\n- `{:ok, job_id}`: If the job is successfully started, it returns the job ID.\r\n- `{:error, error}`: If there is an error in starting the job, it returns the error.\r\n#### Example:\r\n```elixir\r\n{:ok, _job_id} = JobManager.start_job(\"12345\")\r\n```","title":"JobManager.start_job/1","ref":"JobManager.html#start_job/1"},{"type":"function","doc":"Starts the JobManager GenServer with the specified options.\r\n#### Parameters:\r\n- `opts`: A keyword list of options, including `:num_workers` to specify the number of workers and `:name` to set the GenServer name.\r\n#### Returns:\r\n- `{:ok, pid}`: The PID of the started JobManager GenServer.\r\n#### Example:\r\n```elixir\r\n{:ok, _pid} = JobManager.start_link(num_workers: 4, name: :job_manager)\r\n```","title":"JobManager.start_link/1","ref":"JobManager.html#start_link/1"},{"type":"function","doc":"Submits a job to the JobManager with the given job description.\r\n#### Parameters:\r\n- `job_desc`: A map containing the job description, including tasks and their dependencies.\r\n#### Returns:\r\n- `{:ok, job_id}`: If the job is successfully submitted and planned, it returns the job ID.\r\n- `{:error, error}`: If there is an error in planning the job, it returns the error.\r\n#### Example:\r\n```elixir\r\njob_desc = %{\r\n  \"tasks\" => [\r\n    %{\"name\" => \"task1\", \"enables\" => [\"task2\"]},\r\n    %{\"name\" => \"task2\", \"enables\" => []}\r\n  ]\r\n}\r\n{:ok, job_id} = JobManager.submit_job(job_desc)\r\n```","title":"JobManager.submit_job/1","ref":"JobManager.html#submit_job/1"},{"type":"module","doc":"**Planner** is responsible for planning jobs based on their descriptions and the number of workers available.\r\nIt implements Kahn's algorithm to create a plan for executing tasks while respecting their dependencies.","title":"Planner","ref":"Planner.html"},{"type":"module","doc":"- Call `Planner.planning/2` with a job description and the number of workers to get a planned execution order.","title":"Usage: - Planner","ref":"Planner.html#module-usage"},{"type":"module","doc":"```elixir\r\njob_desc = %{\r\n  \"tasks\" => [\r\n    %{\"name\" => \"task1\", \"enables\" => [\"task2\"]},\r\n    %{\"name\" => \"task2\", \"enables\" => []}\r\n  ],\r\n  \"priority\" => [\"task1\"]\r\n}\r\n{:ok, plan} = Planner.planning(job_desc, 2)\r\n```","title":"Example: - Planner","ref":"Planner.html#module-example"},{"type":"module","doc":"- The job description should contain a list of tasks, each with a name and a list of tasks it enables.\r\n- The `planning/2` function will return an ordered list of task groups that can be executed in parallel, respecting their dependencies.\r\n- If the job description contains a \"priority\" field, it will be used to prioritize tasks in the planning.","title":"Notes: - Planner","ref":"Planner.html#module-notes"},{"type":"function","doc":"Finds all tasks that depend on a given start task, including transitive dependencies.\r\n#### Parameters:\r\n- `enables`: A map where keys are task names and values are lists of tasks that the key task enables.\r\n- `start_task`: The task from which to start finding dependent tasks.\r\n#### Returns:\r\n- A list of all tasks that depend on the `start_task`, including transitive dependencies.\r\n#### Example:\r\n```elixir\r\nenables = %{\r\n  \"task1\" => [\"task2\", \"task3\"],\r\n  \"task2\" => [\"task4\"],\r\n  \"task3\" => [],\r\n  \"task4\" => []\r\n}\r\nstart_task = \"task1\"\r\ndependent_tasks = Planner.find_dependent_tasks(enables, start_task)\r\n```","title":"Planner.find_dependent_tasks/2","ref":"Planner.html#find_dependent_tasks/2"},{"type":"function","doc":"","title":"Planner.find_next_independent/3","ref":"Planner.html#find_next_independent/3"},{"type":"function","doc":"Finds the next independent task from a list of tasks, given their dependencies and the already completed tasks.\r\n#### Parameters:\r\n- `tasks`: A list of tasks to check for independence.\r\n- `deps`: A map where keys are task names and values are lists of dependencies for each task.\r\n- `undone`: A list of tasks that are yet to be completed.\r\n- `done`: A list of tasks that have already been completed.\r\n#### Returns:\r\n- The first independent task found in the list, or `nil` if no independent task is found.\r\n#### Example:\r\n```elixir\r\ntasks = [\"task1\", \"task2\", \"task3\"]\r\ndeps = %{\"task1\" => [], \"task2\" => [\"task1\"], \"task3\" => [\"task1\", \"task2\"]}\r\nundone = [\"task2\", \"task3\"]\r\ndone = [\"task1\"]\r\nnext_task = Planner.find_next_independent(tasks, deps, undone, done)\r\n```","title":"Planner.find_next_independent/4","ref":"Planner.html#find_next_independent/4"},{"type":"function","doc":"Groups tasks into independent sets, considering task dependencies and worker limits.\r\n#### Parameters:\r\n- `tasks`: A list of tasks to be grouped.\r\n- `deps`: A map where keys are task names and values are lists of dependencies for each task.\r\n- `num_workers`: The maximum number of workers available for executing tasks. If `:unbound`, it allows dynamic allocation.\r\n#### Returns:\r\n- A list of lists, where each inner list contains tasks that can be executed in parallel, respecting their dependencies.\r\n#### Example:\r\n```elixir\r\ntasks = [\"task1\", \"task2\", \"task3\"]\r\ndeps = %{\"task1\" => [], \"task2\" => [\"task1\"], \"task3\" => [\"task1\", \"task2\"]}\r\nnum_workers = 2\r\ngrouped_tasks = Planner.group_tasks(tasks, deps, num_workers)\r\n```","title":"Planner.group_tasks/3","ref":"Planner.html#group_tasks/3"},{"type":"function","doc":"Groups tasks into independent sets, considering task dependencies and worker limits.\r\n#### Parameters:\r\n- `tasks`: A list of tasks to be grouped.\r\n- `deps`: A map where keys are task names and values are lists of dependencies for each task.\r\n- `num_workers`: The maximum number of workers available for executing tasks. If `:unbound`, it allows dynamic allocation.\r\n- `priority`: A list of tasks that should be prioritized in the grouping.\r\n#### Returns:\r\n- A list of lists, where each inner list contains tasks that can be executed in parallel, respecting their dependencies and priorities.\r\n#### Example:\r\n```elixir\r\ntasks = [\"task1\", \"task2\", \"task3\"]\r\ndeps = %{\"task1\" => [], \"task2\" => [\"task1\"], \"task3\" => [\"task1\", \"task2\"]}\r\nnum_workers = 2\r\npriority = [\"task1\"]\r\ngrouped_tasks = Planner.group_tasks_with_priority(tasks, deps, num_workers, priority)\r\n```","title":"Planner.group_tasks_with_priority/4","ref":"Planner.html#group_tasks_with_priority/4"},{"type":"function","doc":"Implements Kahn's algorithm to find a topological ordering of tasks based on their dependencies.\r\n#### Parameters:\r\n- `dependencies`: A map where keys are task names and values are lists of tasks that depend on the key task.\r\n- `free_tasks`: A list of tasks that have no dependencies and can be executed immediately.\r\n- `planned`: A list that accumulates the planned tasks in the order they can be executed.\r\n#### Returns:\r\n- `{:ok, planned}`: If a valid topological ordering is found, returning the ordered list of tasks.\r\n- `{:error, :graph_has_cycle}`: If a cycle is detected in the task dependencies, making it impossible to create a valid ordering.\r\n#### Example:\r\n```elixir\r\ndependencies = %{\r\n  \"task1\" => [\"task2\"],\r\n  \"task2\" => [],\r\n  \"task3\" => [\"task1\"]\r\n}\r\nfree_tasks = [\"task2\"]\r\nplanned = []\r\n{:ok, ordered_tasks} = Planner.khan_loop(dependencies, free_tasks, planned)\r\n```","title":"Planner.khan_loop/3","ref":"Planner.html#khan_loop/3"},{"type":"function","doc":"Plans a job based on its description and the number of workers available.\r\nIt uses Kahn's algorithm to create a plan for executing tasks while respecting their dependencies.\r\n#### Parameters:\r\n- `job_desc`: A map containing the job description, including tasks and their dependencies.\r\n- `num_workers`: The number of workers available for executing the tasks. It can be an integer or `:unbound` for dynamic allocation.\r\n#### Returns:\r\n- `{:ok, plan}`: A list of task groups that can be executed in parallel, respecting their dependencies.\r\n- `{:error, reason}`: If the job description is invalid or if there is a cycle in the task dependencies.\r\n#### Example:\r\n```elixir\r\njob_desc = %{\r\n  \"tasks\" => [\r\n    %{\"name\" => \"task1\", \"enables\" => [\"task2\"]},\r\n    %{\"name\" => \"task2\", \"enables\" => []}\r\n  ],\r\n  \"priority\" => [\"task1\"]\r\n}\r\n{:ok, plan} = Planner.planning(job_desc, 2)\r\n```","title":"Planner.planning/2","ref":"Planner.html#planning/2"},{"type":"module","doc":"**SPE** is the main module for the SPE (Scalable Parallel Execution) system.\r\nIt is responsible for starting the server, managing job submissions, and handling job starts.\r\nIt uses a GenServer to maintain the state of the system and handle calls related to job management.","title":"SPE","ref":"SPE.html"},{"type":"module","doc":"- Start the SPE server\r\n```elixir\r\n{:ok, _pid} = SPE.start_link(num_workers: 4)\r\n```\r\n- Submit a job\r\n```elixir\r\njob_desc = %{\r\n  \"tasks\" => [\r\n    %{\"name\" => \"task1\", \"enables\" => [\"task2\"]},\r\n    %{\"name\" => \"task2\", \"enables\" => []}\r\n  ]\r\n}\r\n{:ok, job_id} = SPE.submit_job(job_desc)\r\n```\r\n- Start the job\r\n```elixir\r\n{:ok, _job_id} = SPE.start_job(job_id)\r\n```","title":"Usage: - SPE","ref":"SPE.html#module-usage"},{"type":"module","doc":"- The SPE module uses a `JobManager` to handle job submissions and starts.\r\n- It maintains a state that includes waiting jobs, which are jobs that are waiting for their plans to be ready before they can start.\r\n- It logs debug information about job submissions, starts, and other events.","title":"Notes: - SPE","ref":"SPE.html#module-notes"},{"type":"module","doc":"- `GenServer`: For managing the state and handling calls.\r\n- `Logger`: For logging debug information.\r\n- `JobManager`: A module responsible for managing jobs, including submitting jobs, starting them, and handling their plans.\r\n- `SuperManager`: A module responsible for managing the overall system and ensuring that the SPE server is running.","title":"Dependencies: - SPE","ref":"SPE.html#module-dependencies"},{"type":"function","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","title":"SPE.child_spec/1","ref":"SPE.html#child_spec/1"},{"type":"function","doc":"Handles synchronous calls to the SPE server.\r\nIt processes job start requests and job submissions.\r\n#### Parameters:\r\n- `{:start_job, job_id}`: A tuple containing the job ID to start.\r\n- `{:submit_job, job_desc}`: A tuple containing the job description to submit.\r\n#### Returns:\r\n- `{:reply, response, state}`: The response from the JobManager for the job start or submission, along with the current state.\r\n#### Example:\r\n```elixir\r\n{:ok, job_id} = SPE.start_job(\"job_123\")\r\n{:ok, job_id} = SPE.submit_job(%{\"tasks\" => [%{\"name\" => \"task1\", \"enables\" => []}]})\r\n```","title":"SPE.handle_call/3","ref":"SPE.html#handle_call/3"},{"type":"function","doc":"Handles generic info messages sent to the SPE server.\r\nIt logs the received message and returns the current state without any changes.\r\n#### Parameters:\r\n- `msg`: The message received by the SPE server.\r\n#### Returns:\r\n- `{:noreply, state}`: The current state of the SPE server is returned without any changes.\r\n#### Example:\r\n```elixir\r\nSPE.handle_info(:some_info_message, state)\r\n```","title":"SPE.handle_info/2","ref":"SPE.html#handle_info/2"},{"type":"function","doc":"Initializes the SPE server with the given options and state.\r\nThe options can include the number of workers, which will be passed to the JobManager.\r\n#### Parameters:\r\n- `opts`: A keyword list of options, including `:num_workers` to specify the number of workers.\r\n- `state`: The initial state of the SPE server, which includes a map for waiting jobs.\r\n#### Returns:\r\n- `{:ok, state}`: The initial state of the SPE server is returned, ready to handle job submissions and starts.\r\n#### Example:\r\n```elixir\r\n{:ok, _pid} = SPE.start_link(num_workers: 4)\r\n```","title":"SPE.init/1","ref":"SPE.html#init/1"},{"type":"function","doc":"Notifies the SPE server that a job is ready to start.\r\nThis function is called when a job plan is ready, and it will notify the waiting clients that the job can now start.\r\n#### Parameters:\r\n- `job_id`: The ID of the job that is ready to start.\r\n- `response`: The response from the JobManager indicating whether the job can start or if there was an error.\r\n#### Returns:\r\n- `:ok`: If the job is successfully marked as ready to start.\r\n#### Example:\r\n```elixir\r\njob_id = \"12345\"\r\nresponse = {:ok, job_id}\r\nSPE.job_ready(job_id, response)\r\n```","title":"SPE.job_ready/2","ref":"SPE.html#job_ready/2"},{"type":"function","doc":"Starts a job with the given job ID.\r\n#### Parameters:\r\n- `job_id`: The ID of the job to be started.\r\n#### Returns:\r\n- `{:ok, job_id}`: If the job is successfully started, it returns the job ID.\r\n- `{:error, error}`: If there is an error in starting the job, it returns the error.\r\n#### Example:\r\n```elixir\r\n{:ok, _job_id} = SPE.start_job(\"12345\")\r\n```","title":"SPE.start_job/1","ref":"SPE.html#start_job/1"},{"type":"function","doc":"Starts the SPE server with the given options.\r\n#### Parameters:\r\n- `opts`: A keyword list of options, including `:num_workers` to specify the number of workers.\r\n#### Returns:\r\n- `{:ok, pid}`: The PID of the started SPE server.\r\n#### Example:\r\n```elixir\r\n{:ok, _pid} = SPE.start_link(num_workers: 4)\r\n```","title":"SPE.start_link/1","ref":"SPE.html#start_link/1"},{"type":"function","doc":"Submits a job to the SPE server with the given job description.\r\n#### Parameters:\r\n- `job_desc`: A map containing the job description, including tasks and their dependencies.\r\n#### Returns:\r\n- `{:ok, job_id}`: If the job is successfully submitted and planned, it returns the job ID.\r\n- `{:error, :invalid_description}`: If the job description is invalid, it returns an error.\r\n#### Example:\r\n```elixir\r\njob_desc = %{\r\n  \"tasks\" => [\r\n    %{\"name\" => \"task1\", \"enables\" => [\"task2\"]},\r\n    %{\"name\" => \"task2\", \"enables\" => []}\r\n  ]\r\n}\r\n{:ok, job_id} = SPE.submit_job(job_desc)\r\n```","title":"SPE.submit_job/1","ref":"SPE.html#submit_job/1"},{"type":"function","doc":"Terminates the SPE server and stops the Supervisor managing it.\r\nThis function is called when the SPE server is no longer needed, and it will clean up the resources used by the server.\r\n#### Parameters:\r\n- `_reason`: The reason for termination, which is not used in this implementation.\r\n- `state`: The current state of the SPE server, which includes the Supervisor's PID.\r\n#### Returns:\r\n- `:ok`: Indicates that the SPE server has been successfully terminated.\r\n#### Example:\r\n```elixir\r\nSPE.terminate(:normal, state)\r\n```","title":"SPE.terminate/2","ref":"SPE.html#terminate/2"},{"type":"module","doc":"**SuperJob** is responsible for managing the lifecycle of a job, including starting the job and its associated workers.\r\nIt uses a Supervisor to manage the job and its workers, ensuring that they are restarted if they fail.","title":"SuperJob","ref":"SuperJob.html"},{"type":"module","doc":"- Start a SuperJob\r\n```elixir\r\n{:ok, sup_pid} = SuperJob.start_link(job_state, num_workers)\r\n```\r\n- The `job_state` should contain the job ID and any other necessary state information.\r\n- The `num_workers` specifies how many workers should be started for the job.","title":"Usage: - SuperJob","ref":"SuperJob.html#module-usage"},{"type":"module","doc":"- The SuperJob module uses a Supervisor to manage the job and its workers.\r\n- It defines a one-for-one restart strategy, meaning that if a job or worker fails, it will be restarted individually.\r\n- It logs debug information about the job and worker startup processes.","title":"Notes: - SuperJob","ref":"SuperJob.html#module-notes"},{"type":"module","doc":"- `Supervisor`: For managing the job and its workers.\r\n- `Logger`: For logging debug information.","title":"Dependencies: - SuperJob","ref":"SuperJob.html#module-dependencies"},{"type":"function","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","title":"SuperJob.child_spec/1","ref":"SuperJob.html#child_spec/1"},{"type":"function","doc":"Initializes the Supervisor with the children processes that it will manage.\r\nThe children processes include the job and its associated SuperWorker.\r\n#### Parameters:\r\n- `children`: A list of child specifications for the Supervisor, which includes the job and SuperWorker.\r\n#### Returns:\r\n- `{:ok, pid}`: The Supervisor's PID is returned, indicating that it has been successfully started.\r\n#### Example:\r\n```elixir\r\nchildren = [\r\n%{\r\n  id: :job,\r\n  start: {Job, :start_link, [job_state]},\r\n  restart: :transient\r\n},\r\n%{\r\n  id: :super_worker,\r\n  start: {SuperWorker, :start_link, [job_pid, num_workers]},\r\n  restart: :transient\r\n}\r\n]\r\n\r\n{:ok, sup_pid} = SuperJob.init(children)\r\n```","title":"SuperJob.init/1","ref":"SuperJob.html#init/1"},{"type":"function","doc":"Starts a SuperJob with the given job state and number of workers.\r\nThis function initializes the Supervisor and starts the job and its associated SuperWorker.\r\n#### Parameters:\r\n- `job_state`: A map containing the job state, including the job ID and any other necessary information.\r\n- `num_workers`: The number of workers to be started for the job.\r\n#### Returns:\r\n- `{:ok, sup_pid}`: If the SuperJob is successfully started, it returns the Supervisor's PID.\r\n- `{:error, reason}`: If there is an error starting the SuperJob, it returns the error reason.\r\n#### Example:\r\n```elixir\r\njob_state = %{id: \"job_123\", other_info: \"some_info\"}\r\n{:ok, sup_pid} = SuperJob.start_link(job_state, 4)\r\n```","title":"SuperJob.start_link/2","ref":"SuperJob.html#start_link/2"},{"type":"module","doc":"**SuperManager** is responsible for managing the lifecycle of jobs in the SPE system.\r\nIt uses a Supervisor to manage the SuperJob processes, which handle the execution of jobs and their associated workers.","title":"SuperManager","ref":"SuperManager.html"},{"type":"module","doc":"- Start the SuperManager\r\n```elixir\r\n{:ok, _pid} = SuperManager.start_link()\r\n```\r\n- Start a job with the given job state and number of workers\r\n```elixir\r\njob_state = %{id: \"job_1\", ...} # Define the job state as needed\r\n{:ok, _job_pid} = SuperManager.start_job(job_state, 4)\r\n```","title":"Usage: - SuperManager","ref":"SuperManager.html#module-usage"},{"type":"module","doc":"- The SuperManager uses a one-for-one restart strategy, meaning that if a job fails, it will be restarted individually.\r\n- It logs debug information about job starts and the SuperJob processes.","title":"Notes: - SuperManager","ref":"SuperManager.html#module-notes"},{"type":"module","doc":"- `Supervisor`: For managing the SuperJob processes.\r\n- `Logger`: For logging debug information.","title":"Dependencies: - SuperManager","ref":"SuperManager.html#module-dependencies"},{"type":"function","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","title":"SuperManager.child_spec/1","ref":"SuperManager.html#child_spec/1"},{"type":"function","doc":"Initializes the Supervisor with the necessary options.\r\nThis includes setting the strategy to `:one_for_one` and defining the maximum number of restarts and seconds.\r\n#### Parameters:\r\n- `_init_arg`: Initialization argument, not used in this case.\r\n#### Returns:\r\n- `{:ok, pid}`: The Supervisor's PID is returned, indicating that it has been successfully started.\r\n#### Example:\r\n```elixir\r\n{:ok, sup_pid} = SuperManager.start_link()\r\n```","title":"SuperManager.init/1","ref":"SuperManager.html#init/1"},{"type":"function","doc":"Starts a SuperJob with the given job state and number of workers.\r\nThis function initializes the SuperJob process and starts it under the SuperManager Supervisor.\r\n#### Parameters:\r\n- `job_state`: A map containing the job state, including the job ID and any other necessary information.\r\n- `num_workers`: The number of workers to be started for the job.\r\n#### Returns:\r\n- `{:ok, pid}`: The PID of the started SuperJob process is returned, indicating that the job has been successfully started.\r\n#### Example:\r\n```elixir\r\njob_state = %{id: \"job_1\", ...} # Define the job state as needed\r\n{:ok, _job_pid} = SuperManager.start_job(job_state, 4)\r\n```","title":"SuperManager.start_job/2","ref":"SuperManager.html#start_job/2"},{"type":"function","doc":"Starts the SuperManager Supervisor.\r\nThis function initializes the Supervisor and sets it up to manage SuperJob processes.\r\n#### Returns:\r\n- `{:ok, pid}`: The Supervisor's PID is returned, indicating that it has been successfully started.\r\n#### Example:\r\n```elixir\r\n{:ok, sup_pid} = SuperManager.start_link()\r\n```","title":"SuperManager.start_link/0","ref":"SuperManager.html#start_link/0"},{"type":"module","doc":"**SuperWorker** is responsible for managing a set of workers that execute jobs in parallel.\r\nIt uses a Supervisor to manage the workers, ensuring that they are restarted if they fail.","title":"SuperWorker","ref":"SuperWorker.html"},{"type":"module","doc":"- Start a SuperWorker\r\n```elixir\r\n{:ok, sup_pid} = SuperWorker.start_link(job_pid, num_workers)\r\n```\r\n- The `job_pid` is the PID of the job that the workers will execute.\r\n- The `num_workers` specifies how many workers should be started for the job.","title":"Usage: - SuperWorker","ref":"SuperWorker.html#module-usage"},{"type":"module","doc":"- The SuperWorker module uses a Supervisor to manage the workers.\r\n- It defines a one-for-one restart strategy, meaning that if a worker fails, it will be restarted individually.\r\n- It logs debug information about the worker startup processes.","title":"Notes: - SuperWorker","ref":"SuperWorker.html#module-notes"},{"type":"module","doc":"- `Supervisor`: For managing the workers.\r\n- `Logger`: For logging debug information.","title":"Dependencies: - SuperWorker","ref":"SuperWorker.html#module-dependencies"},{"type":"function","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","title":"SuperWorker.child_spec/1","ref":"SuperWorker.html#child_spec/1"},{"type":"function","doc":"Initializes the Supervisor with the necessary options and child processes.\r\nThis includes setting the strategy to `:one_for_one` and defining the maximum number of restarts and seconds.\r\n#### Parameters:\r\n- `info`: A map containing the job PID and the number of workers to be started.\r\n#### Returns:\r\n- `{:ok, pid}`: The Supervisor's PID is returned, indicating that it has been successfully started.\r\n#### Example:\r\n```elixir\r\n{:ok, sup_pid} = SuperWorker.start_link(job_pid, num_workers)\r\n```","title":"SuperWorker.init/1","ref":"SuperWorker.html#init/1"},{"type":"function","doc":"Starts the SuperWorker Supervisor with the given job PID and number of workers.\r\nThis function initializes the Supervisor and sets it up to manage the workers for the specified job.\r\n#### Parameters:\r\n- `job_pid`: The PID of the job that the workers will execute.\r\n- `num_workers`: The number of workers to be started for the job.\r\n#### Returns:\r\n- `{:ok, pid}`: The Supervisor's PID is returned, indicating that it has been successfully started.\r\n#### Example:\r\n```elixir\r\n{:ok, sup_pid} = SuperWorker.start_link(job_pid, num_workers)\r\n```","title":"SuperWorker.start_link/2","ref":"SuperWorker.html#start_link/2"},{"type":"module","doc":"**Validator** is responsible for validating job descriptions and tasks within the SPE system.\r\nIt checks if the job description is a valid map, contains necessary fields, and ensures that tasks are properly defined.","title":"Validator","ref":"Validator.html"},{"type":"module","doc":"- Validate a job description\r\n```elixir\r\nis_valid = Validator.valid_job?(job_desc)\r\n```\r\n- The `job_desc` should be a map containing the job's name and tasks.","title":"Usage: - Validator","ref":"Validator.html#module-usage"},{"type":"module","doc":"- The Validator checks for the presence of required fields, data types, and relationships between tasks.\r\n- It ensures that task names are unique and that the `enables` field in tasks references valid task names.","title":"Notes: - Validator","ref":"Validator.html#module-notes"},{"type":"module","doc":"- `Logger`: For logging debug information during validation.","title":"Dependencies: - Validator","ref":"Validator.html#module-dependencies"},{"type":"function","doc":"Validates a job description to ensure it meets the required structure and constraints.\r\nThis function checks if the job description is a map, contains the necessary fields, and validates each task within the job.\r\n#### Parameters:\r\n- `job`: A map representing the job description, which should include fields like `name` and `tasks`.\r\n#### Returns:\r\n- `true` if the job description is valid, `false` otherwise.\r\n#### Example:\r\n```elixir\r\nis_valid = Validator.valid_job?(%{\"name\" => \"example_job\", \"tasks\" => [...]})\r\n```","title":"Validator.valid_job?/1","ref":"Validator.html#valid_job?/1"},{"type":"module","doc":"**Worker** is responsible for executing tasks within a job in the SPE system.\r\nIt is a GenServer that handles task execution, including applying functions with parameters and managing timeouts.","title":"Worker","ref":"Worker.html"},{"type":"module","doc":"- Start a Worker\r\n```elixir\r\n{:ok, worker_pid} = Worker.start_link(%{job: job_pid})\r\n```\r\n- Send a task to the Worker\r\n```elixir\r\nWorker.send_task(worker_pid, job_id, task_name, timeout, function, params)\r\n```\r\n- Check if the Worker is ready\r\n```elixir\r\nWorker.are_u_ready?(worker_pid)\r\n```","title":"Usage: - Worker","ref":"Worker.html#module-usage"},{"type":"module","doc":"- The Worker uses a GenServer to manage its state and handle task execution.\r\n- It applies functions with parameters and handles exceptions that may occur during execution.\r\n- It communicates task completion back to the Job that it belongs to.","title":"Notes: - Worker","ref":"Worker.html#module-notes"},{"type":"module","doc":"- `GenServer`: For managing the state and handling calls.\r\n- `Logger`: For logging debug information.\r\n- `Phoenix.PubSub`: For broadcasting task start and termination events.","title":"Dependencies: - Worker","ref":"Worker.html#module-dependencies"},{"type":"function","doc":"Applies a function with the given parameters and handles exceptions.\r\nThis function executes the provided function with the specified parameters and manages timeouts and exceptions.\r\n#### Parameters:\r\n- `job_id`: The ID of the job that the task belongs to.\r\n- `task_name`: The name of the task to be executed.\r\n- `timeout`: The timeout for the task execution, in milliseconds.\r\n- `function`: The function to be executed as part of the task.\r\n- `args`: The parameters to be passed to the function.\r\n#### Returns:\r\n- `{:result, result}`: If the function executes successfully, it returns the result wrapped in a tuple.\r\n- `{:failed, reason}`: If the function fails or times out, it returns an error tuple with the reason.\r\n#### Example:\r\n```elixir\r\nresult = Worker.apply(job_id, task_name, timeout, function, args)\r\n```","title":"Worker.apply/5","ref":"Worker.html#apply/5"},{"type":"function","doc":"Checks if the Worker is ready to handle tasks.\r\nThis function sends a call to the Worker to check its readiness.\r\n#### Parameters:\r\n- `worker_pid`: The PID of the Worker to check.\r\n#### Returns:\r\n- `:ok`: Indicates that the Worker is ready to handle tasks.\r\n#### Example:\r\n```elixir\r\nWorker.are_u_ready?(worker_pid)\r\n```","title":"Worker.are_u_ready?/1","ref":"Worker.html#are_u_ready?/1"},{"type":"function","doc":"Returns a specification to start this module under a supervisor.\n\nSee `Supervisor`.","title":"Worker.child_spec/1","ref":"Worker.html#child_spec/1"},{"type":"function","doc":"Handles the call to check if the Worker is ready.\r\nThis function responds to a call to check if the Worker is ready to handle tasks.\r\n#### Parameters:\r\n- `:are_u_ready`: A message indicating that the caller wants to check if the Worker is ready.\r\n#### Returns:\r\n- `{:reply, :ok, state}`: Indicates that the Worker is ready and returns the current state.\r\n#### Example:\r\n```elixir\r\nGenServer.call(worker_pid, :are_u_ready)\r\n```","title":"Worker.handle_call/3","ref":"Worker.html#handle_call/3"},{"type":"function","doc":"Handles the task execution in the Worker.\r\nThis function is called when a task is sent to the Worker. It applies the function with the given parameters and handles the result.\r\n#### Parameters:\r\n- `{:task, {job_id, {name, timeout, fun, params}}}`: A tuple containing the job ID, task name, timeout, function to execute, and parameters.\r\n#### Returns:\r\n- `{:noreply, state}`: Indicates that the Worker has completed the task and is ready for the next one.\r\n#### Example:\r\n```elixir\r\nGenServer.cast(worker_pid, {:task, {job_id, {task_name, timeout, function, params}}})\r\n```","title":"Worker.handle_cast/2","ref":"Worker.html#handle_cast/2"},{"type":"function","doc":"Initializes the Worker with the given state.\r\nThe state should include the job PID that the Worker is associated with.\r\n#### Parameters:\r\n- `state`: A map containing the job PID and any other necessary state information.\r\n#### Returns:\r\n- `{:ok, state}`: The initial state of the Worker is returned, ready to handle tasks.\r\n#### Example:\r\n```elixir\r\n{:ok, worker_pid} = Worker.start_link(%{job: job_pid})\r\n```","title":"Worker.init/1","ref":"Worker.html#init/1"},{"type":"function","doc":"Sends a task to the Worker for execution.\r\nThis function sends a task to the Worker, which includes the job ID, task name, timeout, function to execute, and parameters.\r\n#### Parameters:\r\n- `worker_pid`: The PID of the Worker to which the task will be sent.\r\n- `job_id`: The ID of the job that the task belongs to.\r\n- `name`: The name of the task to be executed.\r\n- `timeout`: The timeout for the task execution, in milliseconds.\r\n- `fun`: The function to be executed as part of the task.\r\n- `params`: The parameters to be passed to the function.\r\n#### Returns:\r\n- `:ok`: Indicates that the task has been sent to the Worker for execution.\r\n#### Example:\r\n```elixir\r\nWorker.send_task(worker_pid, job_id, task_name, timeout, function, params)\r\n```","title":"Worker.send_task/6","ref":"Worker.html#send_task/6"},{"type":"function","doc":"Starts the Worker process with the given state.\r\nThis function initializes the Worker and sets it up to handle tasks.\r\n#### Parameters:\r\n- `state`: A map containing the job PID and any other necessary state information.\r\n#### Returns:\r\n- `{:ok, pid}`: The Worker process's PID is returned, indicating that it has been successfully started.\r\n#### Example:\r\n```elixir\r\n{:ok, worker_pid} = Worker.start_link(%{job: job_pid})\r\n```","title":"Worker.start_link/1","ref":"Worker.html#start_link/1"}],"proglang":"elixir","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.38.2"}}